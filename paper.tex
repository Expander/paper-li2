\documentclass[10pt,DIV16,twocolumn]{scrartcl}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage[german]{authblk}
\usepackage[format=plain,labelfont={bf}]{caption}
\usepackage{listings}
\usepackage{hyperref}

\newcommand{\mytitle}{The performance gain of instruction-level parallelism on the evaluation of special functions}
\newcommand{\myauthor}{Alexander Voigt}

% source code highlighting
\lstset{breaklines=true,
  breakatwhitespace=true,
  % numbers=left,
  % stepnumber=1,
  basicstyle=\ttfamily\lst@ifdisplaystyle\footnotesize\fi, % code block in smaller font
  commentstyle=\ttfamily,
  prebreak={\textbackslash},
  breakindent=10pt,
  breakautoindent=false,
  showspaces=false,
  showstringspaces=false,
  frame=single,
  rulesep=0.1em,
  abovecaptionskip=0em,
  aboveskip=1.5em,
  belowcaptionskip=0.5em,
  belowskip=1em,
  keywordstyle=\color{blue},
  stringstyle=\color{red},
  commentstyle=\color{green},
}

\hypersetup{
  pdftitle   = {\mytitle},
  pdfauthor  = {\myauthor},
  colorlinks = true,
  linkcolor  = blue,
  citecolor  = blue,
  urlcolor   = blue,
  linkcolor  = blue
}

\title{\mytitle}
\author{\myauthor}
\affil{Fachbereich Energie und Biotechnologie, Hochschule Flensburg,\\ Kanzleistra{\ss}e 91--93, 24943 Flensburg, Germany}
\date{\today}

\begin{document}
\maketitle

\section*{Abstract}

\section{Introduction}

\cite{polylogarithm}

\section{Comparison of different implementation strategies}

As a toy example we consider the function $\log(1+x)$, which has the
Taylor expansion
%
\begin{align}
  \log(1+x) \approx x - \frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4} + \frac{x^5}{5} - \frac{x^6}{6} + \frac{x^7}{7}
  \label{eq:taylor}
\end{align}
%
around $x=0$ for $x\in(-1,1]$, where terms of $O(x^8)$ and beyond have
been omitted.  In the following we will briefly study various possible
implementations of this function and compare the performance of the
different implementations.  For brevity we will restrict ourselves to
$x\in(-1,1]$.  In C the function in Eq.~\eqref{eq:taylor} could be
implemented very naively as follows:
%
\lstinputlisting[language=C]{src/log1p_naive.c}
%
This naive implementation requires 26 floating-point multiplications
and 6 floating-point additions.\footnote{Modern compilers usually
  rewrite expensive floating-point divisions by a constant, such as
  $x/2$, as less expensive floating-point multiplication by a
  constant, for example as $0.5x$.  In the following we will therefore
  count a division of a variable by a constant as a floating-point
  multiplication.}

As is well known, the performante of this naive implementation can be
improved by applying Horner's scheme, which reduces the number of
expensive floating-point multiplications to 7 and requires 6
additions:
%
\begin{align}
\begin{split}
  \log(1+x) \approx{}& x \Bigg\{1 + x \Bigg[-\frac{1}{2} + x \Bigg(\frac{1}{3} + x \Bigg\{-\frac{1}{4} \\
  &+ x \Bigg[\frac{1}{5} + x\Bigg(-\frac{1}{6} + \frac{x}{7}\Bigg)\Bigg]\Bigg\}\Bigg)\Bigg]\Bigg\}.
\end{split}\label{eq:horner}%
\end{align}
%
A C implementation using Horner's scheme could read
%
\lstinputlisting[language=C]{src/log1p_horner.c}

Several modern CPU architectures support instruction-level parallelism
(ILP), which allows for the execution of multiple instructions at the
same time.  To make use of ILP to reduce the execution time of the
function, one could use Estrin's scheme \cite{estrin} to rewrite the
function as
%
\begin{align}
\begin{split}
  \log(1+x) \approx{}& x + \left(\frac{x}{3}-\frac{1}{2}\right)
    y \\ &+\left[\left(\frac{x}{7}-\frac{1}{6}\right)
    y+\frac{x}{5}-\frac{1}{4}\right] z,
\end{split}\label{eq:estrin}%
\end{align}
%
where $y=x^2$ and $z=y^2$.  This form requires 8 floating-point
multiplications and 6 additions, i.e.\ more multiplications than
Horner's scheme.  However, in Estrin's form several terms can be
executed in parallel, leading to a potential speed-up.  A C
implementation using Estrin's scheme could read:
%
\lstinputlisting[language=C]{src/log1p_estrin.c}

To exploit ILP further, one could use a rational function
approximation, such as a Padé approximant \cite{pade}, where the
numerator and the denominator can be calculated in parallel.  A Padé
approximant of $\log(1+x)$ at the same order as Eq.~\eqref{eq:taylor}
reads
%
\begin{align}
  \log(1+x) \approx x
  \frac{\frac{40 x^3}{718121}+\frac{79040 x^2}{2154363}+\frac{517208
    x}{718121}+1}{\frac{640 x^3}{718121}+\frac{225120 x^2}{718121}+\frac{876192
    x}{718121}+1}.
  \label{eq:pade}
\end{align}
%
A naive C implementation of Eq.~\eqref{eq:pade} could read:
%
\lstinputlisting[language=C]{src/log1p_pade.c}
%
The numerator and the denominator of Eq.~\eqref{eq:pade} can be
re-written using Estrin's scheme, allowing for further ILP:
%
\lstinputlisting[language=C]{src/log1p_mixed.c}
%
Note that the value $y=x^2$ can be re-used in the calculation of both
the numerator and in the denominator.  This ``mixed'' implementation
requires 8 floating-point multiplications, 1 floating-point division
and 6 additions.

\section{Application to the implementation of the real dilogarithm}

\section{Conclusions}

\bibliographystyle{ieeetr}
\bibliography{paper}

\end{document}
