\documentclass[10pt,DIV16,twocolumn,numbers=noenddot]{scrartcl}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath,amssymb}
\usepackage[german]{authblk}
\usepackage[format=plain,labelfont={bf}]{caption}
\usepackage{listings}
\usepackage[shortcuts]{extdash} % \-/
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{multirow}
\setkomafont{disposition}{\bfseries}

\newcommand{\mytitle}{Comparisons of methods for the calculation of the real dilogarithm regarding instruction-level parallelism}
\newcommand{\myauthor}{Alexander Voigt}
\newcommand{\Li}{\operatorname{Li}_2}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\tabref}[1]{\tablename~\ref{#1}}

% source code highlighting
\lstset{breaklines=true,
  breakatwhitespace=true,
  % numbers=left,
  % stepnumber=1,
  basicstyle=\ttfamily\lst@ifdisplaystyle\footnotesize\fi, % code block in smaller font
  commentstyle=\ttfamily,
  prebreak={\textbackslash},
  breakindent=10pt,
  breakautoindent=false,
  showspaces=false,
  showstringspaces=false,
  frame=single,
  rulesep=0.1em,
  abovecaptionskip=0em,
  aboveskip=1.5em,
  belowcaptionskip=0.5em,
  belowskip=1em,
  keywordstyle=\color{blue},
  stringstyle=\color{red},
  commentstyle=\color{gray},
}

\hypersetup{
  pdftitle   = {\mytitle},
  pdfauthor  = {\myauthor},
  colorlinks = true,
  linkcolor  = blue,
  citecolor  = blue,
  urlcolor   = blue,
  linkcolor  = blue
}

\title{\mytitle}
\author{\myauthor}
\affil{Fachbereich Energie und Biotechnologie, Hochschule Flensburg,\\ Kanzleistra{\ss}e 91--93, 24943 Flensburg, Germany}
\date{\today}

\begin{document}
\maketitle

\section*{Abstract}

We compare different methods for the computation of the real
dilogarithm regarding their ability for using instruction\-/level
parallelism when executed on appropriate CPUs.  As a result we present
an instruction\-/level\-/aware method and compare it to existing
implementations.

\section{Introduction}

The dilogarithm \cite{lewin} is a special function, which appears in
many physics applications, for example in the calculation of quantum
corrections in quantum field theory.  The investigation of new models
beyond the Standard Model of particle physics with a large parameter
space require the evaluation of the dilogarithm (and other functions)
billions of times.  Such investigations thus require a fast evaluation
of the dilogarithm.  In the past many time-efficient algorithms have
been invented (see e.g.~\cite{koelbigDilog,ginsberg,morris}) and many
are implemented, for example, in general-purpose physics and
mathematics program libraries \cite{root,gsl,cephes}.

Many of the publicly available implementations, e.g.\ \cite{root,gsl},
use formulations for the approximation of the dilogarithm with a
strictly sequential execution of floating\-/point operations.  The
development of modern CPUs with support for instruction\-/level
parallelism (ILP) opens the opportunity for a further reduction of the
runtime of the calculation of the dilogarithm.  To make use of ILP,
the algorithm to calculate the dilogarithm must be formulated
appropriately in order to allow for the parallel execution of multiple
floating\-/point operations.  In this paper a method for the
calculation of the real dilogarithm $\Li$ is presented, which makes
use of ILP, potentially resulting in a reduced runtime compared to
many algorithms presented so far.

This paper is organized as follows: In \secref{sec:toymodel} different
implementation strategies are discussed using a toy example function.
In \secref{sec:algorithm} an ILP-aware method for the numerical
calculation of the dilogarithm is presented.  A C implementation of
this method can be found in the appendix and in the arXiv submission
of this paper.

\section{Comparison of implementation strategies}
\label{sec:toymodel}

As a toy example we consider the function $\ln(1+x)$, which has the
Taylor expansion
%
\begin{align}
  \ln(1+x) \approx x - \frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4} + \frac{x^5}{5} - \frac{x^6}{6} + \frac{x^7}{7}
  \label{eq:taylor}
\end{align}
%
around $x=0$ for $x\in(-1,1]$.  In Eq.~\eqref{eq:taylor} terms of
$O(x^8)$ and beyond have been omitted for brevity.  In the following
we will briefly show various possible implementations of this function
and discuss the performance of the different implementations.  For
brevity we will restrict ourselves to $x\in(-1,1]$.  In C the function
in Eq.~\eqref{eq:taylor} could be implemented very naively as follows:
%
\lstinputlisting[language=C]{src/log1p_naive.c}
%
This naive implementation requires 27 floating\-/point multiplications
and 6 floating\-/point additions.  Although all summands in this
implementation can in principle be calculated in parallel, the cost of
the many (redundant) floating\-/point multiplications is usually so
high that this formulated is in total very time\-/inefficient.

As is well known, the performante of this naive implementation can be
improved by applying Horner's scheme, which reduces the number of
expensive floating\-/point multiplications to 7 and requires 6
additions:
%
\begin{align}
\begin{split}
  \ln(1+x) \approx{}& x \bigg\{1 + x \bigg[-\frac{1}{2} + x \bigg(\frac{1}{3} + x \bigg\{-\frac{1}{4} \\
  &+ x \bigg[\frac{1}{5} + x\bigg(-\frac{1}{6} + \frac{x}{7}\bigg)\bigg]\bigg\}\bigg)\bigg]\bigg\}.
\end{split}\label{eq:horner}%
\end{align}
%
A C implementation using Horner's scheme could read
%
\lstinputlisting[language=C]{src/log1p_horner.c}
%
Note, that the formulation using Horner's scheme requires the
evaluation of the floating\-/point operations in strictly sequential
order.  However, the significant reduction of the number of
floating\-/point multiplications, compared to the naive
implementation, usually results in a shorter runtime.

There are several different possibilities to reduce the runtime of
Horner's method by rewriting the series expansion of $\ln(1+x)$ such
that the more terms can be calculated in parallel, while the number
floating\-/point operations is still kept small.  One possibility is
to split the r.h.s.\ of Eq.~\eqref{eq:horner} into two distinct sums,
one containing the even powers and the other containing the odd powers
of $x$,
%
\begin{align}
\begin{split}
  \ln(1+x) \approx{}& x \left\{1 + y \left[\frac{1}{3} + y
  \left(\frac{1}{5} + \frac{y}{7}\right)\right]\right\} \\
  &+ y\left[-\frac{1}{2} + y\left(-\frac{1}{4} - \frac{y}{6}\right)\right],
\end{split}\label{eq:split}%
\end{align}
%
where $y=x^2$.  This formulation requires 8 floating\-/point
multiplications and 6 additions, i.e.\ one more multiplication than
Horner's scheme.  However, in Eq.~\eqref{eq:split} both sums can then
be calculated in parallel, leading to a potential speed-up if the cost
of the additional multiplication is smaller than the gain by the
parallel execution.  A C implementation could read:
%
\lstinputlisting[language=C]{src/log1p_split.c}
%
Another possibility is to rewrite the r.h.s.\ of Eq.~\eqref{eq:taylor}
using Estrin's scheme \cite{estrin},
%
\begin{align}
\begin{split}
  \ln(1+x) \approx{}& x + \left(\frac{x}{3}-\frac{1}{2}\right)
    y \\ &+\left[\left(\frac{x}{7}-\frac{1}{6}\right)
    y+\frac{x}{5}-\frac{1}{4}\right] z,
\end{split}\label{eq:estrin}%
\end{align}
%
where $y=x^2$ and $z=y^2$.  This form also requires 8 floating\-/point
multiplications and 6 additions, as in Eq.~\eqref{eq:split}.  However,
in Estrin's form more terms can be executed in parallel, leading to a
potential further speed-up.  A C implementation using Estrin's scheme
could read:
%
\lstinputlisting[language=C]{src/log1p_estrin.c}

To exploit ILP further, one could use a rational function
approximation, such as a Padé approximant \cite{pade}, where the
numerator and the denominator can be calculated in parallel.  A Padé
approximant of $\ln(1+x)$ at the same order as Eq.~\eqref{eq:taylor}
reads
%
\begin{align}
  \ln(1+x) \approx x
  \frac{\frac{320 x^3}{40143}+\frac{44320 x^2}{120429}+\frac{51064
    x}{40143}+1}{\frac{5120 x^3}{40143}+\frac{12320 x^2}{13381}+\frac{23712
    x}{13381}+1}.
  \label{eq:pade}
\end{align}
%
A naive C implementation of Eq.~\eqref{eq:pade} could read:
%
\lstinputlisting[language=C]{src/log1p_pade.c}
%
The numerator and the denominator of Eq.~\eqref{eq:pade} can be
re-written using Estrin's scheme, allowing for further ILP:
%
\begin{align}
  \ln(1+x) \approx x
  \frac{\left(\frac{320 x}{40143}+\frac{44320}{120429}\right)y+\frac{51064
    x}{40143}+1}{\left(\frac{5120 x}{40143}+\frac{12320}{13381}\right)y+\frac{23712
    x}{13381}+1},
  \label{eq:mixed}
\end{align}
%
where $y=x^2$.  A C implementation could read:
%
\lstinputlisting[language=C]{src/log1p_mixed.c}
%
Note that the value $y=x^2$ can be re-used in the calculation of both
the numerator and in the denominator.  This ``mixed'' implementation
requires 8 floating\-/point multiplications, 1 floating\-/point
division and 6 additions.  The rational function approximation
\eqref{eq:mixed} may be faster for long numerator/denominator
polynomials, where the cost of the floating\-/point division is
smaller than the gain by the parallel execution of the terms in the
numerator and denominator.


\section{An ILP-aware method for the real dilogarithm}
\label{sec:algorithm}

In the following an ILP-aware implementation of the real dilogarithm
is presented, which allows for the parallel execution of different
floating\-/point operations.  The real dilogarithm is defined as
%
\begin{align}
  \Li(x) &= -\int_0^x \frac{\ln(1-t)}{t}dt, &
  &x<1.
\end{align}
%
For $|x|<1$ the real dilogarithm has the series representation
%
\begin{align}
  \Li(x) = \sum_{k=1}^\infty \frac{x^k}{k^2}.
  \label{eq:series}
\end{align}
%
Further series representations exist, for example the accelerated
series
%
\begin{align}
  \Li(x) = \sum_{k=0}^\infty \frac{B_k}{(k+1)!} [-\ln(1-x)]^{k+1},
\end{align}
%
where $B_k$ are the Bernoulli numbers.  A series representation in
terms of Chebyshev polynomials of the first kind $T_n(x)$ is given in
\cite{luke},
%
\begin{align}
  \Li(x) = \sum_{k=0}^\infty a_n T_n(2x-1),
  \label{eq:cheby}
\end{align}
%
which is used for example in the ROOT program library \cite{root}.
The r.h.s.\ of Eqs.~\eqref{eq:series}--\eqref{eq:cheby} can be summed,
for example, using Horner's scheme or Clenshaw's algorithm
\cite{clenshaw}.  These summation techniques are, however, purely
sequential and thus do not make use of ILP.  In the following an
approximation of the real dilogarithm is presented, which makes use of
ILP, using a rational function approximation in combination with
Estrin's scheme, similar to the approach used in
Eq.~\eqref{eq:mixed}.%
\footnote{The Cephes library \cite{cephes} implements an equivalent
  rational function approximation for Spence's function
  $\operatorname{Sp}(x)=\Li(1-x)$.}

We define the real dilogarithm $\Li(x)$ for all $x\in\mathbb{R}$ as
the real part of its complex continuation.  The real dilogarithm can
be mapped onto the interval $[0,1/2]$ by using the following
identities \cite{lewin}:
%
\begin{align}
  \Li(x) ={}& \ln(1-x)\left[\frac{1}{2}\ln(1-x) - \ln(-x)\right] - \frac{\pi^2}{6}
              \notag \\ &+\Li\left(\frac{1}{1-x}\right), \quad x\leq -1, \\
  \Li(x) ={}& -\Li\left(\frac{x}{x-1}\right) - \frac{1}{2}\ln^2(1-x),
              \notag \\ & -1<x<0, \\
  \Li(x) ={}& -\Li(1-x) + \frac{\pi^2}{6} - \ln(x) \ln(1-x),
              \notag \\ &\frac{1}{2}<x<1, \\
  \Li(x) ={}& \frac{\pi^2}{6} - \ln(x)\left[\ln\left(1-\frac{1}{x}\right) + \frac{1}{2}\ln(x)\right]
              \notag \\ &+ \Li\left(1-\frac{1}{x}\right), \quad 1<x\leq 2, \\
  \Li(x) ={}& -\Li\left(\frac{1}{x}\right) + \frac{\pi^2}{3} - \frac{1}{2} \ln^2(x), \quad x>2,
\end{align}
%
and by using the special values $\Li(-1)=-\pi^2/12$, $\Li(0)=0$,
$\Li(1/2)=\pi^2/12-\ln^2(2)/2$, $\Li(1)=\pi^2/6$ and $\Li(2)=\pi^2/4$.
Within the interval $[0,1/2]$ the real dilogarithm has the series
expansion \eqref{eq:series}, which can be written as
%
\begin{align}
  \Li(x) = x \sum_{k=0}^\infty \frac{x^{k}}{(k+1)^2}.
  \label{eq:series2}
\end{align}
%
We approximate the sum on the r.h.s.\ of Eq.~\eqref{eq:series2} in the
form of a rational minimax approximant on the interval $[0,1/2]$ using
the \texttt{MiniMaxApproximation} from Wolfram/Mathematica
\cite{mathematica},
%
\begin{align}
  \sum_{k=0}^\infty \frac{x^{k}}{(k+1)^2} \approx
  \frac{\sum_{k=0}^5 p_kx^k}{\sum_{k=0}^6 q_kx^k}.
  \label{eq:minimax}
\end{align}
%
The coefficients $p_k$ and $q_k$ are listed in \tabref{tab:coeffs}.
%
\begin{table}[t]
  \centering
  \caption{Coefficients of the numerator and denominator polynomials
    for the minimax approximant \eqref{eq:minimax}.}
  \begin{tabular}{lr}
    \toprule
    $p_0$ & $ 0.9999999999999999502\cdot 10^{+0}$ \\
    $p_1$ & $-2.6883926818565423430\cdot 10^{+0}$ \\
    $p_2$ & $ 2.6477222699473109692\cdot 10^{+0}$ \\
    $p_3$ & $-1.1538559607887416355\cdot 10^{+0}$ \\
    $p_4$ & $ 2.0886077795020607837\cdot 10^{-1}$ \\
    $p_5$ & $-1.0859777134152463084\cdot 10^{-2}$ \\
    $q_0$ & $ 1.0000000000000000000\cdot 10^{+0}$ \\
    $q_1$ & $-2.9383926818565635485\cdot 10^{+0}$ \\
    $q_2$ & $ 3.2712093293018635389\cdot 10^{+0}$ \\
    $q_3$ & $-1.7076702173954289421\cdot 10^{+0}$ \\
    $q_4$ & $ 4.1596017228400603836\cdot 10^{-1}$ \\
    $q_5$ & $-3.9801343754084482956\cdot 10^{-2}$ \\
    $q_6$ & $ 8.2743668974466659035\cdot 10^{-4}$ \\
    \bottomrule
  \end{tabular}
  \label{tab:coeffs}
\end{table}

In \tabref{tab:runtime} the runtime of different C implementations is
compared on two different CPU architectures.  On each architecture the
implentations are compiled with \texttt{g++} with optimization
\texttt{-O2}.  The shown runtime denotes the total wall clock time for
the calculation of $\Li(x)$ for $10^6$ uniformly distributed random
values $x\in[-5,5]$.
%
\begin{table}[tb]
  \centering
  \caption{Runtime in seconds for the calculation of $\Li(x)$ for
    different implementations on different CPU architectures with
    different compilers.}
  \begin{tabular}{lcc}
    \toprule
    \multirow{2}{*}{Implementation} & i7-4700MQ & i7-5600U \\
    & \texttt{g++} 10.2.1 & \texttt{g++} 9.3.0 \\
    \midrule
    this paper & $0.031$ & $0.026$ \\
    Morris (DILOG 0011) \cite{morris} & $0.035$ & $0.026$ \\
    Cephes \cite{cephes} & $0.044$ & $0.034$ \\
    Algorithm 327 \cite{koelbigDilog} & $0.054$ & $0.035$ \\
    Chebyshev \cite{luke} & $0.079$ & $0.060$ \\
    Algorithm 490 \cite{ginsberg} & $0.125$ & $0.071$ \\
    GSL \cite{gsl} & $0.330$ & $0.155$ \\
    \bottomrule
  \end{tabular}
  \label{tab:runtime}
\end{table}
%
We find that the implementation presented in this paper and the
approach presented in \cite{morris} are fastest among the ones shown
in the table.  The next-to fastest implementation is provided by
Cephes, which is only $\sim 20\%$ slower.  The short runtime of Cephes
stems from the fact that Cephes also uses a rational function
approximation, where the numerator and the denominator can be
evaluated in parallel.  However, Cephes evaluates the polynomials in
the numerator and denominator using Horner's scheme, which is purely
sequential.  Furthermore, for $x>1$ Cephes calculates $\ln(x)$ twice,
which leads to a further slowdown.

\section{Conclusions}

C, C++ and FORTRAN implementations of the presented algorithm can be
found in the Polylogarithm library \cite{polylogarithm}.
Implementations in Julia and Rust can be found in \cite{PolyLog.jl}
and \cite{polylog}, respectively.

\appendix

\section{Implementation of the real dilogarithm}

\lstinputlisting[language=C]{anc/Li2.c}


\bibliographystyle{ieeetr}
\bibliography{paper}

\end{document}
